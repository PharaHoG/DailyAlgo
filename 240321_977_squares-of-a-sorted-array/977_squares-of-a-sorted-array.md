# 977.有序数组的平方

## 题目描述



给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2：**

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```



## 方法一：双指针法（左右指针）



- **思路**
  - 由于给定数组按非递减顺序排序，每个数字的平方的最大值可能出现在数组的**左右两端**
  - 使用双指针法，从左右向中间移动，比较每次左右指针所指值的大小
  - **左指针超过右指针**（为什么？）时，循环结束



**源代码：**

```cpp
vector<int> sortedSquares(vector<int>& nums) {
        int lef = 0, rig = nums.size() - 1; // 左闭右闭区间
        vector<int> result(nums.size(), 0);
        int k = nums.size() - 1;

    	// 每次循环结束后，lef与rig大小判断前
    	// lef或rig所指值都还未被加入到result数组中
    	// 因此，如果使用 '<'
    	// 那么lef与rig所指值（同一个）将不会被加入到数组
        while(lef <= rig) {
            if(nums[lef] * nums[lef] > nums[rig] * nums[rig]) {
                result[k--] = nums[lef] * nums[lef];
                lef++;
            } else {
                result[k--] = nums[rig] * nums[rig];
                rig--;
            }
        }

        return result;
    }
```

> **注意点:**
>
> 1. 边界情况的判断，关于“是否能等于”的问题
>    - 见 [关于边界情况的一点思考](..\Insights\关于边界情况的一点思考.md)
